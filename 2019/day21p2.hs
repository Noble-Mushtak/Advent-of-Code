import qualified Data.Array as A
import qualified Data.List as L

compose2 :: (c -> d) -> (a -> b -> c) -> (a -> b -> d)
compose2 f g a b = f $ g a b

rawProgram :: [Int]
rawProgram = [109,2050,21102,1,966,1,21102,1,13,0,1106,0,1378,21102,1,20,0,1106,0,1337,21101,0,27,0,1106,0,1279,1208,1,65,748,1005,748,73,1208,1,79,748,1005,748,110,1208,1,78,748,1005,748,132,1208,1,87,748,1005,748,169,1208,1,82,748,1005,748,239,21101,0,1041,1,21102,73,1,0,1105,1,1421,21102,78,1,1,21101,1041,0,2,21102,1,88,0,1105,1,1301,21102,68,1,1,21102,1,1041,2,21102,103,1,0,1106,0,1301,1102,1,1,750,1106,0,298,21102,1,82,1,21102,1041,1,2,21101,125,0,0,1105,1,1301,1101,2,0,750,1105,1,298,21101,0,79,1,21101,1041,0,2,21101,147,0,0,1106,0,1301,21101,0,84,1,21102,1,1041,2,21102,1,162,0,1106,0,1301,1102,3,1,750,1106,0,298,21102,1,65,1,21102,1041,1,2,21102,1,184,0,1106,0,1301,21101,0,76,1,21102,1041,1,2,21101,0,199,0,1106,0,1301,21101,0,75,1,21102,1041,1,2,21101,0,214,0,1106,0,1301,21102,221,1,0,1106,0,1337,21102,10,1,1,21101,1041,0,2,21102,1,236,0,1106,0,1301,1105,1,553,21102,1,85,1,21101,0,1041,2,21102,1,254,0,1106,0,1301,21101,78,0,1,21101,0,1041,2,21102,269,1,0,1105,1,1301,21101,0,276,0,1105,1,1337,21101,0,10,1,21101,1041,0,2,21101,291,0,0,1106,0,1301,1101,1,0,755,1105,1,553,21102,32,1,1,21102,1041,1,2,21101,0,313,0,1106,0,1301,21102,1,320,0,1106,0,1337,21101,327,0,0,1106,0,1279,2101,0,1,749,21101,65,0,2,21101,0,73,3,21102,1,346,0,1106,0,1889,1206,1,367,1007,749,69,748,1005,748,360,1101,0,1,756,1001,749,-64,751,1106,0,406,1008,749,74,748,1006,748,381,1101,-1,0,751,1105,1,406,1008,749,84,748,1006,748,395,1101,0,-2,751,1105,1,406,21101,1100,0,1,21102,1,406,0,1106,0,1421,21101,32,0,1,21102,1100,1,2,21101,421,0,0,1106,0,1301,21102,428,1,0,1106,0,1337,21101,0,435,0,1106,0,1279,2101,0,1,749,1008,749,74,748,1006,748,453,1101,-1,0,752,1106,0,478,1008,749,84,748,1006,748,467,1102,1,-2,752,1106,0,478,21101,1168,0,1,21102,1,478,0,1105,1,1421,21101,0,485,0,1105,1,1337,21102,10,1,1,21102,1,1168,2,21102,500,1,0,1106,0,1301,1007,920,15,748,1005,748,518,21102,1209,1,1,21102,518,1,0,1106,0,1421,1002,920,3,529,1001,529,921,529,1002,750,1,0,1001,529,1,537,1002,751,1,0,1001,537,1,545,1002,752,1,0,1001,920,1,920,1106,0,13,1005,755,577,1006,756,570,21101,1100,0,1,21101,570,0,0,1105,1,1421,21102,1,987,1,1106,0,581,21101,0,1001,1,21101,588,0,0,1106,0,1378,1102,1,758,594,102,1,0,753,1006,753,654,20102,1,753,1,21102,1,610,0,1106,0,667,21101,0,0,1,21102,621,1,0,1105,1,1463,1205,1,647,21101,1015,0,1,21101,635,0,0,1106,0,1378,21102,1,1,1,21101,646,0,0,1106,0,1463,99,1001,594,1,594,1105,1,592,1006,755,664,1102,0,1,755,1106,0,647,4,754,99,109,2,1102,726,1,757,21201,-1,0,1,21102,9,1,2,21101,0,697,3,21102,692,1,0,1106,0,1913,109,-2,2106,0,0,109,2,101,0,757,706,1201,-1,0,0,1001,757,1,757,109,-2,2105,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,255,63,159,223,191,127,95,0,217,116,190,245,34,136,235,118,153,70,227,139,39,43,222,56,213,143,137,115,110,78,49,94,196,182,229,38,220,51,101,203,154,188,169,242,58,244,93,173,175,214,254,243,54,251,174,198,200,177,234,61,155,219,181,98,215,247,241,206,201,156,207,202,167,189,250,114,252,158,166,253,218,46,125,120,199,77,109,140,152,239,186,170,86,197,121,178,84,100,62,55,102,35,123,237,171,85,163,162,42,231,111,99,124,107,142,187,79,47,233,205,168,221,103,232,92,179,226,249,246,184,172,69,50,204,113,122,248,138,119,185,183,236,108,71,126,60,53,212,68,157,228,141,87,117,106,238,59,230,216,76,57,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,73,110,112,117,116,32,105,110,115,116,114,117,99,116,105,111,110,115,58,10,13,10,87,97,108,107,105,110,103,46,46,46,10,10,13,10,82,117,110,110,105,110,103,46,46,46,10,10,25,10,68,105,100,110,39,116,32,109,97,107,101,32,105,116,32,97,99,114,111,115,115,58,10,10,58,73,110,118,97,108,105,100,32,111,112,101,114,97,116,105,111,110,59,32,101,120,112,101,99,116,101,100,32,115,111,109,101,116,104,105,110,103,32,108,105,107,101,32,65,78,68,44,32,79,82,44,32,111,114,32,78,79,84,67,73,110,118,97,108,105,100,32,102,105,114,115,116,32,97,114,103,117,109,101,110,116,59,32,101,120,112,101,99,116,101,100,32,115,111,109,101,116,104,105,110,103,32,108,105,107,101,32,65,44,32,66,44,32,67,44,32,68,44,32,74,44,32,111,114,32,84,40,73,110,118,97,108,105,100,32,115,101,99,111,110,100,32,97,114,103,117,109,101,110,116,59,32,101,120,112,101,99,116,101,100,32,74,32,111,114,32,84,52,79,117,116,32,111,102,32,109,101,109,111,114,121,59,32,97,116,32,109,111,115,116,32,49,53,32,105,110,115,116,114,117,99,116,105,111,110,115,32,99,97,110,32,98,101,32,115,116,111,114,101,100,0,109,1,1005,1262,1270,3,1262,20102,1,1262,0,109,-1,2105,1,0,109,1,21101,0,1288,0,1105,1,1263,20101,0,1262,0,1101,0,0,1262,109,-1,2105,1,0,109,5,21102,1310,1,0,1106,0,1279,22102,1,1,-2,22208,-2,-4,-1,1205,-1,1332,22102,1,-3,1,21102,1332,1,0,1106,0,1421,109,-5,2105,1,0,109,2,21102,1,1346,0,1106,0,1263,21208,1,32,-1,1205,-1,1363,21208,1,9,-1,1205,-1,1363,1105,1,1373,21101,1370,0,0,1106,0,1279,1106,0,1339,109,-2,2106,0,0,109,5,2102,1,-4,1386,20101,0,0,-2,22101,1,-4,-4,21101,0,0,-3,22208,-3,-2,-1,1205,-1,1416,2201,-4,-3,1408,4,0,21201,-3,1,-3,1106,0,1396,109,-5,2106,0,0,109,2,104,10,21202,-1,1,1,21101,1436,0,0,1106,0,1378,104,10,99,109,-2,2106,0,0,109,3,20002,594,753,-1,22202,-1,-2,-1,201,-1,754,754,109,-3,2105,1,0,109,10,21101,0,5,-5,21101,0,1,-4,21102,0,1,-3,1206,-9,1555,21102,3,1,-6,21102,1,5,-7,22208,-7,-5,-8,1206,-8,1507,22208,-6,-4,-8,1206,-8,1507,104,64,1106,0,1529,1205,-6,1527,1201,-7,716,1515,21002,0,-11,-8,21201,-8,46,-8,204,-8,1106,0,1529,104,46,21201,-7,1,-7,21207,-7,22,-8,1205,-8,1488,104,10,21201,-6,-1,-6,21207,-6,0,-8,1206,-8,1484,104,10,21207,-4,1,-8,1206,-8,1569,21101,0,0,-9,1105,1,1689,21208,-5,21,-8,1206,-8,1583,21101,1,0,-9,1106,0,1689,1201,-5,716,1588,21001,0,0,-2,21208,-4,1,-1,22202,-2,-1,-1,1205,-2,1613,22102,1,-5,1,21102,1,1613,0,1105,1,1444,1206,-1,1634,21201,-5,0,1,21102,1,1627,0,1105,1,1694,1206,1,1634,21101,2,0,-3,22107,1,-4,-8,22201,-1,-8,-8,1206,-8,1649,21201,-5,1,-5,1206,-3,1663,21201,-3,-1,-3,21201,-4,1,-4,1105,1,1667,21201,-4,-1,-4,21208,-4,0,-1,1201,-5,716,1676,22002,0,-1,-1,1206,-1,1686,21102,1,1,-4,1106,0,1477,109,-10,2105,1,0,109,11,21102,1,0,-6,21101,0,0,-8,21102,0,1,-7,20208,-6,920,-9,1205,-9,1880,21202,-6,3,-9,1201,-9,921,1725,20101,0,0,-5,1001,1725,1,1732,21002,0,1,-4,21202,-4,1,1,21102,1,1,2,21101,0,9,3,21102,1754,1,0,1105,1,1889,1206,1,1772,2201,-10,-4,1766,1001,1766,716,1766,21002,0,1,-3,1105,1,1790,21208,-4,-1,-9,1206,-9,1786,22102,1,-8,-3,1106,0,1790,22102,1,-7,-3,1001,1732,1,1796,20102,1,0,-2,21208,-2,-1,-9,1206,-9,1812,22101,0,-8,-1,1105,1,1816,22102,1,-7,-1,21208,-5,1,-9,1205,-9,1837,21208,-5,2,-9,1205,-9,1844,21208,-3,0,-1,1106,0,1855,22202,-3,-1,-1,1105,1,1855,22201,-3,-1,-1,22107,0,-1,-1,1105,1,1855,21208,-2,-1,-9,1206,-9,1869,21202,-1,1,-8,1106,0,1873,21201,-1,0,-7,21201,-6,1,-6,1105,1,1708,21202,-8,1,-10,109,-11,2106,0,0,109,7,22207,-6,-5,-3,22207,-4,-6,-2,22201,-3,-2,-1,21208,-1,0,-6,109,-7,2106,0,0,0,109,5,1201,-2,0,1912,21207,-4,0,-1,1206,-1,1930,21101,0,0,-4,22101,0,-4,1,21201,-3,0,2,21102,1,1,3,21101,0,1949,0,1106,0,1954,109,-5,2106,0,0,109,6,21207,-4,1,-1,1206,-1,1977,22207,-5,-3,-1,1206,-1,1977,21202,-5,1,-5,1106,0,2045,22102,1,-5,1,21201,-4,-1,2,21202,-3,2,3,21102,1,1996,0,1105,1,1954,21201,1,0,-5,21102,1,1,-2,22207,-5,-3,-1,1206,-1,2015,21101,0,0,-2,22202,-3,-2,-3,22107,0,-4,-1,1206,-1,2037,21202,-2,1,1,21101,2037,0,0,106,0,1912,21202,-3,-1,-3,22201,-5,-3,-5,109,-6,2105,1,0]

type Program = A.Array Int Int

program :: Program
program = A.listArray (0, 3000) (rawProgram ++ (repeat 0))

data Mode = Position | Immediate | Relative deriving (Enum)

runProgram' :: [Int] -> Int -> Int -> Program -> [Int]
runProgram' inputs relBase curLoc prog =
  let infoCell = prog A.! curLoc
      opCode = infoCell `mod` 100
      mode1 = toEnum $ (infoCell `quot` 100) `mod` 10 
      mode2 = toEnum $ (infoCell `quot` 1000) `mod` 10
      mode3 = toEnum $ (infoCell `quot` 10000) `mod` 10 in
  case opCode of
    99 -> []
    _ -> let (_, lastInd) = A.bounds prog
             lastParamLoc = curLoc+(numParams opCode) in
         if lastParamLoc <= lastInd then
           let runP = runProgram' inputs relBase in
           case opCode of
             1 -> runP (curLoc+4) $ calcOp mode1 mode2 mode3 (+)
             2 -> runP (curLoc+4) $ calcOp mode1 mode2 mode3 (*)
             
             3 -> case inputs of
                    [] -> error "Not enough inputs"
                    input:rst ->
                      runProgram' rst relBase (curLoc+2) $
                         prog A.// [((readLoc mode1 (curLoc+1)), input)]
                           
             4 -> (:) (readElem mode1 (curLoc+1)) $
                    runP (curLoc+2) prog
                    
             5 -> if ((readElem mode1 (curLoc+1)) == 0)
                  then runP (curLoc+3) prog
                  else runP (readElem mode2 (curLoc+2)) prog
             6 -> if ((readElem mode1 (curLoc+1)) /= 0)
                  then runP (curLoc+3) prog
                  else runP (readElem mode2 (curLoc+2)) prog
                  
             7 -> runP (curLoc+4) $
                    calcOp mode1 mode2 mode3 (fromEnum `compose2` (<))
             8 -> runP (curLoc+4) $
                    calcOp mode1 mode2 mode3 (fromEnum `compose2` (==))

             9 -> runProgram' inputs (relBase+(readElem mode1 (curLoc+1))) (curLoc+2) prog
                    
             _ -> error "Unrecognized opcode"
         else error "Not enough parameters"
  where numParams 1 = 3
        numParams 2 = 3
        numParams 3 = 1
        numParams 4 = 1
        numParams 5 = 2
        numParams 6 = 2
        numParams 7 = 3
        numParams 8 = 3
        numParams 9 = 1
        numParams _ = 0

        readLoc Position loc = prog A.! loc
        readLoc Immediate loc = loc
        readLoc Relative loc = relBase+(prog A.! loc)

        readElem m loc = prog A.! (readLoc m loc)

        calcOp mode1 mode2 mode3 f =
          let firstElem = readElem mode1 (curLoc+1)
              secondElem = readElem mode2 (curLoc+2)
              destLoc = readLoc mode3 (curLoc+3) in
          prog A.// [(destLoc, f firstElem secondElem)]

runProgram :: Program -> [Int] -> [Int]
runProgram prog inputs = runProgram' inputs 0 0 prog

-- (NOT C OR NOT B OR NOT A) AND D AND (E OR H)
progInput :: String
progInput = (++"\n") $ L.intercalate "\n" instructions
  where instructions = ["NOT C T", "OR T J", "NOT B T", "OR T J", "NOT A T", "OR T J", "AND D J", "NOT E T", "NOT T T", "OR H T", "AND T J", "RUN"]

main :: IO ()
main = do
  let allOutputs = runProgram program $ map fromEnum progInput
  --putStrLn $ map toEnum allOutputs
  print $ last allOutputs